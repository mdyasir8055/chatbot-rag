# AI Sales Consultant – Codebase Documentation (main.py line-by-line)

This document explains what each part of `main.py` does, why it exists generally, and why it’s used in this codebase. It also includes setup and run instructions.

---

## Table of Contents
1. Setup & Run
2. Glossary (Slug, OCR, RAG, Retriever)
3. High-level Architecture
4. API Endpoints Overview
5. Line-by-line Walkthrough of main.py
   - Imports and setup (1–47)
   - FastAPI app and CORS (48–57)
   - Directories and global state (59–82)
   - ProductExtractor class (84–201)
   - Pydantic models (203–218)
   - URL and text helpers (219–359)
   - Official brand domains, URL guessing, dealer search (360–626)
   - External info fetch helpers (627–740)
   - RAG setup: PDFs, URLs, multi-PDF (661–873)
   - AutoGen agents config (874–909)
   - New routes for parameter extraction + confirmation (911–1005)
   - Status and upload routes (1006–1195)
   - Chat route + external enrichment logic (1121+)
   - Frontend static serving (if any route below)
6. Notes on Configuration and Extensibility

Line numbers reference the repository’s current `main.py`.

---

## 1) Setup & Run

### Prerequisites
- Python 3.10+
- Windows 11 recommended (project uses Windows paths)
- Tesseract (optional, for OCR fallback) and Poppler (for pdf2image) if you need OCR

### Environment variables
- `GOOGLE_API_KEY` or `GEMINI_API_KEY`: API key for Google Generative AI (Gemini)
- `GEMINI_MODEL` (optional): defaults to `gemini-1.5-flash`
- Optional OCR-related environment variables if you want to hard-set paths, or use the runtime settings in `app_state.ocr_settings`.

### Install dependencies
```bash
pip install -r requirements.txt
```

### Run the server
```bash
uvicorn main:app --reload --host 0.0.0.0 --port 8000
```
Open http://localhost:8000 and the UI is served from `static/index.html` if you open it directly, or consume the API endpoints.

---

## 2) Glossary
- **Slug**: A URL- and filename-friendly identifier derived from a human-readable name. Generally used to create stable keys, collection names, and safe paths. In this code, slugs identify vector DB collections and help build URLs.
- **OCR (Optical Character Recognition)**: Extracts text from images/scanned PDFs. Used here as a fallback when a PDF has no embedded text. Implemented via `pdf2image` (rendering pages to images) + `pytesseract` (recognizing text).
- **RAG (Retrieval-Augmented Generation)**: A pattern where we retrieve relevant chunks from a knowledge base (vector DB) and pass them to an LLM to ground responses in facts.
- **Retriever**: An interface to query the vector database (Chroma) for the most relevant text chunks to a given user question.

---

## 3) High-level Architecture
- Users upload PDFs or provide URLs.
- Text is split, embedded with Google Generative AI embeddings, and stored in Chroma.
- At chat time, the system retrieves relevant chunks and optionally enriches with curated external sources.
- Responses are generated by a conversational agent using retrieved facts.

---

## 4) API Endpoints Overview
- `POST /api/upload-pdf-with-extraction`: Upload PDFs and immediately extract brand/model/category guesses from the filename/content.
- `POST /api/confirm-and-process`: User confirms parameters; pipeline builds RAG index.
- `GET /api/chat/greeting`: Personalized greeting with detected parameters.
- `GET /api/status`: Current system status (which sources loaded, location, etc.).
- `POST /api/upload-pdf`: Upload and index 1 or more PDFs.
- `POST /api/setup-urls`: Build an index from a set of URLs.
- `POST /api/chat`: Chat endpoint using retrieval + optional external enrichment.

---

## 5) Line-by-line Walkthrough of main.py

### Imports and setup (1–47)
- 1–4: Standard libs (`os`, `time`, `asyncio`, typing) – used across the app for file paths, timing, concurrency, and type hints.
- 5–7: FastAPI imports – define the app and responses.
- 8: `pydantic.BaseModel` – request/response validation and parsing.
- 9: `autogen` – defines LLM agents used for analysis and conversation.
- 10: `dotenv.load_dotenv` – loads environment variables from a `.env` file.
- 11: `uvicorn` – ASGI server to run FastAPI.
- 12: `PyPDF2` – reads text from PDFs when embedded text exists.
- 13: `re` – regular expressions for pattern matching and tokenization.
- 14: `traceback` – prints detailed errors for debugging.
- 16–21: Optional import of Gemini client error, with a fallback – robust error handling when Google client isn’t installed.
- 23–27: LangChain imports – loaders, vector store (Chroma), embedding model wrapper, and text splitter for RAG.
- 28–31: `requests`, `BeautifulSoup`, `urlparse` – HTTP fetching and HTML parsing for external enrichment.
- 31–37: Randomization, PDF to image (OCR), Tesseract, PIL, temp dirs, and GC – supporting OCR fallback when PDFs are images.
- 38–41: Document class import (LangChain varies) – ensures compatibility across versions.
- 43–46: Load `.env`, read `GOOGLE_API_KEY` or `GEMINI_API_KEY` – required for embeddings and LLMs.

Why: These imports enable PDF processing, RAG, external enrichment, and API serving.

### FastAPI app and CORS (48–57)
- 48: Create `FastAPI` app with title/version.
- 51–57: Add CORS middleware to allow cross-origin requests (handy during development and when UI is served separately).

Why: Exposes HTTP endpoints and enables browser-based usage from different origins.

### Directories and global state (59–82)
- 59–62: `os.makedirs` creates `static` and `data` if missing – static assets and uploaded PDFs.
- 63–82: `app_state` – in-memory state for:
  - `retriever`: vector retriever handle
  - product metadata (brand/model/category/name, URL)
  - user location
  - external enrichment toggle
  - OCR settings (enable, pages, bin paths)

Why: Centralizes runtime configuration/state for API handlers.

### ProductExtractor class (84–201)
- 85–103: Defines brand/category indicators and patterns for `automotive`, `pharmaceutical`, `electronics` – used to guess brand/model from filename/content.
- 105–115: `detect_category` – scores indicators in the combined filename+content; picks the category with max hits.
- 116–161: `extract_parameters` – orchestrates extraction; combines filename-based and content-based signals; builds `product` name and confidence.
- 163–181: `_extract_from_filename` – tokenizes filename and matches against known brand lists; uses next token as model candidate.
- 182–190: `_extract_from_content` – category regex patterns to detect "Brand Model" in text.
- 192–199: `_clean_filename` – fallback product name when brand/model not detected.

Why: Enables auto-detection and pre-fill of fields for confirmation.

### Pydantic models (203–218)
- 204–206: `ChatMessage` – payload for chat requests.
- 207–211: `SettingsUpdate` – runtime config updates (location, disable external, OCR settings).
- 212–214: `URLInput` – list of URLs to index.
- 215–218: `ChatResponse` – response schema for chat.

Why: Validated data shapes between frontend and backend.

### URL and text helpers (219–359)
- 220–266: `build_candidate_urls_by_category(product, category, brand, location)` – builds seed URLs by category. Automotive is now generic (brand-agnostic); pharma/electronics add relevant sites and common general sources. We use `slug` (derived from product) and `city` (from location) to form search-friendly URLs.
- 263–267: `infer_product_name_from_path` – derive name from file path by stripping separators.
- 268–314: `infer_product_name_from_content` – heuristic scanning of first pages to find a likely product name/title.
- 315–329: `extract_pdf_text_fast` – quick read of the first 3 pages, stop early when enough text.
- 330–337: `extract_relevant_sentences` & `extract_price_sentences` – regex-based pickers for approval or pricing statements.

Why: Builds external URL lists and supports extracting semantic hints for presentation.

### Official brand domains, URL guessing, dealer search (360–626)
- 366–377: `_normalize_keywords` – normalize query text.
- 379–390: `extract_sentences_by_keywords` – lightweight keyword sentence extraction.
- 392–404: `_official_brand_domains(brand)` – GENERIC implementation to guess official domains without brand-specific overrides.
- 407–411: `is_official_domain(domain, brand)` – tags content as "official" when domain matches guessed brand domains.
- 412–451: `guess_official_url(product)` – probes candidate official URLs and returns the first that loads with relevant signals.
- 515–523: `extract_city_from_location` – pulls city name from location string; defaults to "Chennai".
- 524–527: `needs_dealer_search` – detects dealer-related queries.
- 556–626: `fetch_official_dealers_generic`/`fetch_official_dealers` – construct likely dealer locator URLs from domains and heuristically extract dealer entries.

Why: Improves trust by preferring official pages and offering dealer info for automotive.

### External info fetch helpers (627–740)
- 627–654: `fetch_external_approval_info` – mines candidate sites for approval-related snippets (useful for pharmaceutical).
- 655–660: `needs_external_search` – decides when to augment with external sources for approval-type queries.
- 453–506 (earlier): `fetch_external_general_info` – general enrichment by keywords; respects official URL if found.
- 338–353 (earlier): `fetch_external_pricing_info` – price-centric enrichment.

Why: Controlled external augmentation to complement brochure facts.

### RAG setup: PDFs, URLs, multi-PDF (661–873)
- 661–739: `setup_rag_pipeline(pdf_path, product_slug)` –
  - Uses `PyPDFLoader` + `RecursiveCharacterTextSplitter` to chunk content.
  - Embeds with `GoogleGenerativeAIEmbeddings` (model `models/embedding-001`).
  - Stores in Chroma collection named by `product_slug` and embedding model.
  - If no text chunks found, tries OCR fallback for the first N pages.
  - Updates `app_state` with counts and retriever.
- 740–807: `setup_rag_pipeline_from_urls(urls, product_slug)` – same idea but loads content from URLs.
- 809–873: `setup_multiple_pdfs(pdf_paths, product_slug)` – merges multiple PDFs into one index; includes OCR fallback per file.

Why: Builds the knowledge base used at chat time.

### AutoGen agents config (874–909)
- 874–878: Model and LLM config setup – sets temperature, timeouts.
- 879–888: `InsightExtractor` – a precise agent to distill retrieved facts into bullet points.
- 890–902: `SalesConversationalist` – a friendly agent to produce user-facing answers based on insights.
- 904–909: `UserProxy` – coordinates the multi-agent interaction without human input.

Why: Separates fact extraction from conversational phrasing.

### New routes for parameter extraction + confirmation (911–1005)
- 913–951: `POST /api/upload-pdf-with-extraction` –
  - Stores uploaded PDFs, quickly extracts text from first pages.
  - Uses `ProductExtractor` to guess `brand`, `model`, `category`, and build `product`.
  - Returns a list with guessed parameters per file for user confirmation.
- 953–1005: `POST /api/confirm-and-process` –
  - Accepts user-confirmed `brand`, `model`, `category`, `product_name` for a `pdf_path`.
  - Updates `app_state`, builds `product_slug` and sets up the full RAG pipeline.
  - Optionally guesses the official product URL.

Why: Adds a two-step upload-confirm process to ensure correctness before indexing.

### Status and upload routes (1006–1195)
- 1006–1035: `GET /api/chat/greeting` – personalized greeting using confirmed product info.
- 1038–1051: `GET /api/status` – diagnostics and flags for the UI.
- 1052–1095: `POST /api/upload-pdf` – upload one or many PDFs and index directly; sets `product_slug` from filenames.
- 1096–1120: `POST /api/setup-urls` – index a set of URLs.

Why: Core endpoints to load knowledge sources and inspect state.

### Chat route + external enrichment (1121+)
- 1121–: `POST /api/chat` –
  - Validates that a retriever exists.
  - Retrieves context from vector DB.
  - Optionally augments with external info (official URL guessing, approval, pricing, dealer search) based on query intent and `app_state.disable_external`.
  - Uses the two-agent pipeline to produce the final answer.

Why: Delivers fact-grounded, helpful responses.

---

## 6) Notes on Configuration and Extensibility
- Brand-specific code removed: `_official_brand_domains` is now generic and `build_candidate_urls_by_category` automotive block is brand-agnostic.
- You can externalize brand/domain mappings or source lists into a JSON or environment config to avoid code changes.
- OCR behavior is controlled via `app_state["ocr_settings"]`; set `tesseract_cmd` and `poppler_path` as needed.
- Location defaults to Chennai for deterministic demos; update `app_state.user_location` or provide a settings route to change it.

---

If you want a literal, every-single-line annotation (1:1), we can generate a separate detailed file in chunks to keep it maintainable. This README focuses on line-anchored sections with rationale for clarity and practicality.